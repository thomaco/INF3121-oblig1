\documentclass{article}

\usepackage[margin=1in]{geometry} % narrow margins
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{tabulary}
\usepackage{verbatim}
\usepackage{listings}

%\usepackage{hyperref}
%\usepackage{listings}
%\usepackage[cm]{fullpage}
\renewcommand{\labelenumii}{\arabic{enumii}.}



\title{Project 1 \\ Report \\ INF4121/3121} % Title
\date{\today} % Date for the report
\author{Sebasting SÃ¸berg(INF4121) \& Thomas Oddsund(INF3121)}

\begin{document}

\maketitle % Insert the title, author and date

%Requirement 1
\section{\textit{Requirement 1} - Description, analysis and test cases}

	\subsection{Description}
	We are going to review the program Hangman, which derives its name from the game, written in the language Java. The program consists of 5 source files, namely;
	\begin{itemize}
	\item Command.java
	\item FileReadWriter.java
	\item Game.java
	\item HangmanTets.java
	\item Players.java
	\end{itemize}

	\textbf{Command.java} only contains an enumerated type, which contains the possible commands for the program. \textbf{FileReadWriter.java} contains the logic for reading from and writing player objects to file for the scoreboard functionality, as well as a method for sorting and printing the scoreboard. \textbf{Game.java} contains the logic for the game itself, which means handling out, user input, checking input and printing the game dialogue. \textbf{HangmanTets.java} only initializes and starts the Game.java logic. \textbf{Players.java} contains the data structure for a player, as well as methods for fetching name and score.
	%end descrition

	\subsection{Analysis of the testable parts of the program\newline}
	As this program shipped with no requirment, we had to rely on experience and knowledge about the game of hangman to create a model of the flow of the program. This model was based both on our experience, as well as observed behaviour of the program. From this model, we could use black-box technique to design test cases for the program. The test cases were then built as pr. definition, with pre- and post-conditions, inital state, result and steps.

	\subsection{Test cases}
	
 %Start of test-cases
%Missing test-case for checking number of mistakes is correct?
	\begin{enumerate}
	\setlength\itemsep{1em}

	\item \textbf{Start Hangman}\newline
	\textbf{Initial state:} No program running.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item Run "java -cp . hangman.HangmanTets" from the folder containing the hangman folder with binaries
	\end{enumerate}
	\textbf{Expected results:} Game displays welcome-statement:
	\begin{lstlisting}[breaklines, gobble=8]
	Welcome to the Hangman game. Please, try to guess my secret word.
	Use 'TOP' to view the top scoreboard, 'RESTART' to start a new game, 
	'HELP' to cheat and 'EXIT' to quit the game.
	The secret word is:  *One-or-more underlines*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} Game awaits input

	\item \textbf{Correct letter entered}\newline
	\textbf{Initial State:} Multiple underlines are displayed in the secret word, more then one unique letter missing.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X.
	\end{enumerate}
	\textbf{Expected results:} Game displayes the following message; 
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	The secret word is: *Current state of secret word,  letter X revealed*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} One or more underlines are replaced with the letter in the correct position, game awaits input.

	\item \textbf{Wrong letter entered}\newline
	\textbf{Initial State:} One or more underlines are displayed in the secret word.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters an invalid letter X.
	\end{enumerate}
	\textbf{Expected results:} Game displays the following error message: 
	\begin{lstlisting}[breaklines, gobble=8]
	Sorry! There are no unrevealed letters 'X'. 
	The secret word is:  *Current state of secret word*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} The state of the secret word remains unchanged, mistake counter increased by one.

	\item \textbf{Correct letter reveals last letter(no help used)}\newline
	\textbf{Initial State:} One unique letter missing and no help used.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X
	\end{enumerate}
	\textbf{Expected results:}Game displays the following success-message;
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	You won with Y mistake(s).
	The secret word is:  *SECRET WORD*
	Please enter your name for the top scoreboard:
	\end{lstlisting}
	Where Y is the number of unique incorrect letters typed in by the user.\newline
	\textbf{Post condition:}Game ready for input for scoreboard\newline

	\item \textbf{Single non-alphabetic character}\newline
	\textbf{Initial State:} Game running, awaiting input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item Users enters a non-alphabetic character.
	\end{enumerate}
	\textbf{Expected results:} Game ignores input, asks for new character.\newline
	\textbf{Post condition:} Game awaits input.

	\item \textbf{Multiple characters entered}\newline
	\textbf{Initial State:} Game running, awaiting input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters multiple characters.
	\end{enumerate}
	\textbf{Expected results:} Game ignores input, asks for a new character.\newline
	\textbf{Post condition:} Game awaits input.

	\item \textbf{Help command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "help"
	\end{enumerate}
	\textbf{Expected results:} One letter is revealed in the secret word. help flag set for user in this game.\newline
	\textbf{Post condition:} Help flag is set on user, game awaits user input.\newline

	\item \textbf{Correct letter reveals last letter(help used)}\newline
	\textbf{Initial State:} One unique letter missing and help used.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X.
	\end{enumerate}
	\textbf{Expected results:}
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	You won with Y mistake(s). but you have cheated. You are not allowed to 
	enter into the scoreboard.
	The secret word is:  *SECRET WORD*
	\end{lstlisting}
	Where Y is the number of unique incorrect letter typed in by the user.\newline
	\textbf{Post condition:} Game restarts, then displays welcome statement and awaits input.\newline

	\item \textbf{Restart command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "restart"
	\end{enumerate}
	\textbf{Expected results:} The game starts a new game.\newline
	\textbf{Post condition:} New game with a new word running, game awaits user input.\newline

	\item \textbf{Exit command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "exit"
	\end{enumerate}
	\textbf{Expected results:}Game exits\newline
	\textbf{Post condition:}No game running\newline

	\item \textbf{User enters name for scoreboard}\newline
	\textbf{Initial State:} User have guessed the correct word without the help command.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User guesses the correct word
	\item User inputs name for scoreboard
	\end{enumerate}
	\textbf{Expected results:} Name+score stored in records, new game started\newline
	\textbf{Post condition:} Scoreboard has one new entry containing the playername + score, and a new game has started.\newline

	\item \textbf{Top command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "top"
	\end{enumerate}
	\textbf{Expected results:} Game displays the scoreboard and starts a new game.\newline
	\textbf{Post condition:} Game awaits user input.\newline
	\end{enumerate}
 %End of test-cases

	\begin{comment}
	\begin{center}
		\begin{tabulary}{1.0\textwidth}{| C | p{3cm} | p{1.6cm} |  p{4.4cm}|  p{5.5cm} |}
		\hline
			\textbf{\#} & \textbf{Pre-condition} & \textbf{Inputs} & \textbf{Expected results} & \textbf{Post-conditions} \\ \hline
			1 & No game running & Start the game & Welcome-message and\newline commands displayed,\newline game started & Game ready for character \\ \hline
			2 & Game running & Not a letter & Prompt for a new\newline character & No change of game state \\ \hline
			3 & Game running & More then one character\newline entered & Prompt for a new\newline character & No change of game state \\ \hline
			4 & Game running,\newline all dashes & Correct letter & Letter revealed & Dash removed in solution word where correct letter is placed and ready for next letter \\ \hline
			5 & Game running,\newline all dashes & Wrong letter & No letter revealed & Message stating that no letters were found and ready for new letter \\ \hline
			6 & Game running,\newline one or more letters\newline revealed & Correct letter & Letter revealed & Dash removed in solution word where correct letter is placed and ready for next letter \\ \hline
			7 & Game running,\newline one or more letters\newline revealed & Wrong letter & No letter revealed & Message stating that no letters were found and ready for new letter \\ \hline
			8 & Game running,\newline one letter missing,\newline no help used & Correct letter & Success-message and number of errors printed, asks for name for scoreboard, new round started & New game with a new random word started \\ \hline
			9 & Game running,\newline one letter missing,\newline help used & Correct letter & Success-message, message about help used, new round started & New game with a new random word started \\ \hline
			10 & 
		\end{tabulary}
	\end{center}
	\end{comment}


	\subsection{Design of manual system tests}


	\subsection{Test cases}


%Requirment 2
\section{Metrics at project and file level}

\subsection{Metrics at project level}

\subsection{Metrics at file level}

%Requirement 3
\section{Improvements based on metrics}

\subsection{Metrics at project level that needs improvment}

\subsection{List of improved/refactored code}
%Both list of code files, and link to github public repo

\subsection{New metrics at project level vs old}

\subsection{New metrics at file level vs old}

\section{Conclusion}
make a couple of remarks about how easy or not it was for you to maintain the code
(to modify it in order to improve it). Is there anything that you would have done differently on
the ini'al code to make its maintenance easier?

\end{document}