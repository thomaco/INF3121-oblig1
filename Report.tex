\documentclass{article}

\usepackage[margin=1in]{geometry} % narrow margins
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{tabulary}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{graphicx}

%\usepackage{hyperref}
%\usepackage{listings}
%\usepackage[cm]{fullpage}
\renewcommand{\labelenumii}{\arabic{enumii}.}



\title{Project 1 \\ Report \\ INF4121/3121} % Title
\date{\today} % Date for the report
\author{Sebasting SÃ¸berg(INF4121) \& Thomas Oddsund(INF3121)}

\begin{document}

\maketitle % Insert the title, author and date

%Requirement 1
\section{\textit{Requirement 1} - Description, analysis and test cases}

	\subsection{Description}
	We are going to review the program Hangman, which derives its name from the game, written in the language Java. The program consists of 5 source files, namely;
	\begin{itemize}
	\item Command.java
	\item FileReadWriter.java
	\item Game.java
	\item HangmanTets.java
	\item Players.java
	\end{itemize}

	\textbf{Command.java} only contains an enumerated type, which contains the possible commands for the program. \textbf{FileReadWriter.java} contains the logic for reading from and writing player objects to file for the scoreboard functionality, as well as a method for sorting and printing the scoreboard. \textbf{Game.java} contains the logic for the game itself, which means handling out, user input, checking input and printing the game dialogue. \textbf{HangmanTets.java} only initializes and starts the Game.java logic. \textbf{Players.java} contains the data structure for a player, as well as methods for fetching name and score.
	%end descrition

	\subsection{Analysis of the testable parts of the program}
	As this program shipped with no requirment, we had to rely on experience and knowledge about the game of hangman to create a model of the flow of the program. This model was based both on our experience, as well as observed behaviour of the program. From this model, we could use black-box technique to design test cases for the program. The test cases were then built as pr. definition, with pre- and post-conditions, inital state, result and steps.
	
	Out previous experience and knowledge helped us in setting up the requirements and model, from which we derived the different test cases. For the test cases, it especially made us set up cases for various forms of input, both valid and invalid, as this is the main vector from which users interact with the system.
\pagebreak

	\subsection{Test cases}
 %Start of test-cases
%Missing test-case for checking number of mistakes is correct?
	\begin{enumerate}
	\setlength\itemsep{1em}

	\item \textbf{Start Hangman}\newline
	\textbf{Initial state:} No program running.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item Run "java -cp . hangman.HangmanTets" from the folder containing the hangman folder with binaries
	\end{enumerate}
	\textbf{Expected results:} Game displays welcome-statement:
	\begin{lstlisting}[breaklines, gobble=8]
	Welcome to the Hangman game. Please, try to guess my secret word.
	Use 'TOP' to view the top scoreboard, 'RESTART' to start a new game, 
	'HELP' to cheat and 'EXIT' to quit the game.
	The secret word is:  *One-or-more underlines*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} Game awaits input

	\item \textbf{Correct letter entered}\newline
	\textbf{Initial State:} Multiple underlines are displayed in the secret word, more then one unique letter missing.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X.
	\end{enumerate}
	\textbf{Expected results:} Game displayes the following message; 
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	The secret word is: *Current state of secret word,  letter X revealed*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} One or more underlines are replaced with the letter in the correct position, game awaits input.

	\item \textbf{Wrong letter entered}\newline
	\textbf{Initial State:} One or more underlines are displayed in the secret word.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters an invalid letter X.
	\end{enumerate}
	\textbf{Expected results:} Game displays the following error message: 
	\begin{lstlisting}[breaklines, gobble=8]
	Sorry! There are no unrevealed letters 'X'. 
	The secret word is:  *Current state of secret word*
	Enter your guess(1 letter allowed):
	\end{lstlisting}
	\textbf{Post condition:} The state of the secret word remains unchanged, mistake counter increased by one.

	\item \textbf{Correct letter reveals last letter(no help used)}\newline
	\textbf{Initial State:} One unique letter missing and no help used.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X
	\end{enumerate}
	\textbf{Expected results:} Game displays the following success-message;
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	You won with Y mistake(s).
	The secret word is:  *SECRET WORD*
	Please enter your name for the top scoreboard:
	\end{lstlisting}
	Where Y is the number of unique incorrect letters typed in by the user.\newline
	\textbf{Post condition:}Game ready for input for scoreboard\newline
	
	\item \textbf{Correct number of mistakes(help/no help irellevant)}\newline
	\textbf{Initial State:} One unique letter missing.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X.
	\end{enumerate}
	\textbf{Expected results:} Game displays the following success-message;
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	You won with Y mistake(s).
	The secret word is:  *SECRET WORD*
	\end{lstlisting}
	Where Y is the \textbf{correct} number of unique incorrect letters typed in by the user.\newline
	\textbf{Post condition:} Game ready for input for scoreboard.

	\item \textbf{Single non-alphabetic character}\newline
	\textbf{Initial State:} Game running, awaiting input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item Users enters a non-alphabetic character.
	\end{enumerate}
	\textbf{Expected results:} Game ignores input, asks for new character.\newline
	\textbf{Post condition:} Game awaits input.

	\item \textbf{Multiple characters entered}\newline
	\textbf{Initial State:} Game running, awaiting input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters multiple characters.
	\end{enumerate}
	\textbf{Expected results:} Game ignores input, asks for a new character.\newline
	\textbf{Post condition:} Game awaits input.

	\item \textbf{Help command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "help"
	\end{enumerate}
	\textbf{Expected results:} One letter is revealed in the secret word. help flag set for user in this game.\newline
	\textbf{Post condition:} Help flag is set on user, game awaits user input.\newline

	\item \textbf{Correct letter reveals last letter(help used)}\newline
	\textbf{Initial State:} One unique letter missing and help used.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters a valid letter X.
	\end{enumerate}
	\textbf{Expected results:}
	\begin{lstlisting}[breaklines, gobble=8]
	Good job! You revealed 1 letter(s).
	You won with Y mistake(s). but you have cheated. You are not allowed to 
	enter into the scoreboard.
	The secret word is:  *SECRET WORD*
	\end{lstlisting}
	Where Y is the number of unique incorrect letter typed in by the user.\newline
	\textbf{Post condition:} Game restarts, then displays welcome statement and awaits input.\newline

	\item \textbf{Restart command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "restart"
	\end{enumerate}
	\textbf{Expected results:} The game starts a new game.\newline
	\textbf{Post condition:} New game with a new word running, game awaits user input.\newline

	\item \textbf{Exit command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "exit"
	\end{enumerate}
	\textbf{Expected results:}Game exits\newline
	\textbf{Post condition:}No game running\newline

	\item \textbf{User enters name for scoreboard}\newline
	\textbf{Initial State:} User have guessed the correct word without the help command.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User guesses the correct word
	\item User inputs name for scoreboard
	\end{enumerate}
	\textbf{Expected results:} Name+score stored in records, new game started\newline
	\textbf{Post condition:} Scoreboard has one new entry containing the playername + score, and a new game has started.\newline

	\item \textbf{Top command}\newline
	\textbf{Initial State:} Game running and awaiting user input.\newline
	\textbf{Steps:}
	\begin{enumerate}
	\item User enters "top"
	\end{enumerate}
	\textbf{Expected results:} Game displays the scoreboard and starts a new game.\newline
	\textbf{Post condition:} Game awaits user input.\newline
	\end{enumerate}

	\textbf{Non-functional testing}
	After some discussion we realized that some factors in non-functional testing
	are of importance. Namely:
	\begin{enumerate}
		\item
		\textbf{Performance}
		The performance of the program can be tested. Since this is supposed to be a rather simple program,
		a few things to test can be that it handles input fast enough(i.e. that it prints out correct/incorrect, and that it's ready
		for new input within a set time) and that it uses minimal amount of memory(i.e. locked device where it runs in a continuous
		loop can lead to a stack overflow if it continuously instantiates new classes in the wrong way).
		\begin{comment}
		After each game "round" the program calls: new Game()
		which can be a performance bottleneck whereas one plays
		this game several million times. This can happen in situations
		where this program are loaded onto a locked device for playing.
		So instead of calling new Game() one should simply call a startMethod instead.
		And move the internal statements in the constructor over in that method so we 
		avoid having multiple Games on the stack which increases space requirements.
		\end{comment}

		\item
		\textbf{Maintainability}
		All systems, even a small and easy one, should be properly documented, via comments, names of variables, method names
		etc. It probably isn't necesearry with a huge document base for a project of this size, but for maintainability in the future,
		the program should have the proper amount of comments, and proper names on variables, methods etc.
		\begin{comment}
		The system is poorly documented and the statements is not intuitively named everywhere.
		There are also some methods which doesn\'t do anything except increasing the complexity of
		the program. Also there are places where exceptions are caught individually without any
		purpose. And all of this makes the code harder to analyze and or change.
		\end{comment}

	\end{enumerate}


 %End of test-cases

%Requirment 2
\section{\textit{Requirement 2} - Metrics at project and file level}

\subsection{Metrics at project level}



%metrics at project level
\begin{enumerate}
\item
The metrics of Checkpoint summary:
\vspace {0.08 cm}

\begin{tabulary}{1.0\textwidth}{| C | l |}
	\hline
	\textbf{Parameter} & \textbf{Value} \\ \hline
	Files & 5 \\ \hline
	Lines & 441 \\ \hline
	Statements & 222 \\ \hline
	Percent Branch Statements & 18.5 \\ \hline
	Method Call Statements & 147 \\ \hline
	Percent Lines with Comments & 5.2 \\ \hline
	Classes and Interfaces & 5 \\ \hline
	Methods per Class & 4,20 \\ \hline
	Average Statements per Method & 8,14 \\ \hline
	Name of Most Complex Method & Game.findLetterAndPrintlt() \\ \hline
	Maximum Complexity & 12 \\ \hline
	Maximum Block Depth & 9+ \\ \hline
	Average Block Depth & 2,90 \\ \hline
	Average Complexity & 2,95 \\ \hline
	Line Number of Most Complex Method & undefined \\ \hline
	Line Number of Deepest Block & undefined \\ \hline
\end{tabulary}
\newline
\vspace*{0.5 cm}
\newline
Kiviat Graph:
\vspace {0.08 cm}

\begin{comment}
\begin{tabulary}{1.0\textwidth}{| C | p{3cm} |}
 \hline
Comments = 5,2[8-20] & Under \\ \hline
Methods/Class = 4,20[4-16] & Expected \\ \hline
Avd Stmts/Method = 8,14[6-12] & Expected \\ \hline
Max Complexity = 12[2-8] & Over \\ \hline
Max Depth = 9+[3-7] & Over \\ \hline
Av Depth = 2,90[1.0-2.2] & Over \\ \hline
Avg Complexity = 2,95[2.0-4.0] & Expected \\ \hline
\end{tabulary}
\end{comment}

\includegraphics[width=0.9\textwidth]{Hangman-Kiviat-before.png}

We think that \textit{Comments, Max Complexity, Max Depth and Avg Depth}
need to change. 

\pagebreak
\item
The biggest file by the number of lines is fileReadWriter.java with 219 lines.


\item
The file with the most branches is fileReadWriter.java where the branches stands for
20,8 % of the file. 


\item
The file with the most complex code is Game.java. The metrics used for this conclusion is Max complexity and Game.java's score here was 12. 

\end{enumerate}
\subsection{Metrics at file level}

%Requirement 3
\section{\textit{Requirement 3} -Improvements based on metrics}

\subsection{Metrics at project level that needs improvment}

\subsection{List of improved/refactored code}
%Both list of code files, and link to github public repo

\subsection{New metrics at project level vs old}

\subsection{New metrics at file level vs old}

\section{Conclusion}
make a couple of remarks about how easy or not it was for you to maintain the code
(to modify it in order to improve it). Is there anything that you would have done differently on
the ini'al code to make its maintenance easier?

\end{document}